<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Equirectangular Panorama Viewer</title>
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}
		
		body {
			font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
			overflow: hidden;
			background: #000;
		}
		
		#container {
			width: 100vw;
			height: 100vh;
			position: relative;
		}
		
		#upload-overlay {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: #1a1a1a;
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			z-index: 10;
			transition: opacity 0.3s;
		}
		
		#upload-overlay.hidden {
			opacity: 0;
			pointer-events: none;
		}
		
		#upload-overlay.drag-over {
			background: #2a2a2a;
		}
		
		.upload-content {
			text-align: center;
			color: #fff;
			max-width: 500px;
			padding: 40px;
		}
		
		.upload-content h1 {
			font-size: 32px;
			margin-bottom: 16px;
		}
		
		.upload-content p {
			font-size: 16px;
			color: #aaa;
			margin-bottom: 32px;
		}
		
		.upload-area {
			border: 3px dashed #555;
			border-radius: 12px;
			padding: 60px 40px;
			cursor: pointer;
			transition: all 0.3s;
		}
		
		.upload-area:hover {
			border-color: #888;
			background: rgba(255, 255, 255, 0.05);
		}
		
		.upload-icon {
			font-size: 64px;
			margin-bottom: 16px;
		}
		
		.upload-btn {
			background: #007bff;
			color: #fff;
			border: none;
			padding: 12px 32px;
			font-size: 16px;
			border-radius: 6px;
			cursor: pointer;
			transition: background 0.3s;
		}
		
		.upload-btn:hover {
			background: #0056b3;
		}
		
		#file-input {
			display: none;
		}
		
		#controls {
			position: absolute;
			bottom: 20px;
			left: 50%;
			transform: translateX(-50%);
			background: rgba(0, 0, 0, 0.7);
			padding: 12px 20px;
			border-radius: 8px;
			color: #fff;
			font-size: 14px;
			z-index: 5;
			display: none;
		}
		
		#controls.visible {
			display: block;
		}
		
		#reload-btn {
			position: absolute;
			top: 20px;
			right: 20px;
			background: rgba(0, 0, 0, 0.7);
			color: #fff;
			border: 1px solid #555;
			padding: 10px 20px;
			border-radius: 6px;
			cursor: pointer;
			font-size: 14px;
			z-index: 5;
			display: none;
			transition: background 0.3s;
		}
		
		#reload-btn:hover {
			background: rgba(0, 0, 0, 0.9);
		}
		
		#reload-btn.visible {
			display: block;
		}
	</style>
</head>
<body>
	<div id="container"></div>
	
	<div id="upload-overlay">
		<div class="upload-content">
			<h1>360Â° Image Viewer</h1>
			<p>Load an equirectangular 360Â° image to explore it in immersive view</p>
			<div class="upload-area" id="upload-area">
				<div class="upload-icon">ðŸ“·</div>
				<button class="upload-btn" id="upload-btn">Choose Image</button>
				<p style="margin-top: 16px; font-size: 14px;">or drag and drop here</p>
			</div>
		</div>
	</div>
	
	<input type="file" id="file-input" accept="image/*">
	
	<div id="controls">
		Click and drag to look around â€¢ Scroll to zoom
	</div>
	
	<button id="reload-btn">Load New Image</button>

	<script src="three.min.js"></script>
	<script>
let scene, camera, renderer, sphere, texture;
let isMouseDown = false;
let mouseX = 0,
	mouseY = 0;
let lon = 0,
	lat = 0;
let phi = 0,
	theta = 0;
const fov = 75;

const container = document.getElementById('container');
const uploadOverlay = document.getElementById('upload-overlay');
const uploadArea = document.getElementById('upload-area');
const uploadBtn = document.getElementById('upload-btn');
const fileInput = document.getElementById('file-input');
const controls = document.getElementById('controls');
const reloadBtn = document.getElementById('reload-btn');

function init() {
	// Scene setup
	scene = new THREE.Scene();

	// Camera setup
	camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 0.1, 1000);
	camera.position.set(0, 0, 0.1);

	// Renderer setup
	renderer = new THREE.WebGLRenderer({
		antialias: true
	});
	renderer.setSize(window.innerWidth, window.innerHeight);
	container.appendChild(renderer.domElement);

	// Sphere geometry (inverted to see inside)
	const geometry = new THREE.SphereGeometry(500, 60, 40);
	geometry.scale(-1, 1, 1); // Invert to see from inside

	// Event listeners
	renderer.domElement.addEventListener('mousedown', onMouseDown);
	renderer.domElement.addEventListener('mousemove', onMouseMove);
	renderer.domElement.addEventListener('mouseup', onMouseUp);
	renderer.domElement.addEventListener('wheel', onWheel);

	// Touch events
	renderer.domElement.addEventListener('touchstart', onTouchStart);
	renderer.domElement.addEventListener('touchmove', onTouchMove);
	renderer.domElement.addEventListener('touchend', onTouchEnd);

	window.addEventListener('resize', onWindowResize);

	// Upload events
	uploadBtn.addEventListener('click', () => fileInput.click());
	uploadArea.addEventListener('click', () => fileInput.click());
	fileInput.addEventListener('change', handleFileSelect);

	// Drag and drop
	uploadOverlay.addEventListener('dragover', handleDragOver);
	uploadOverlay.addEventListener('dragleave', handleDragLeave);
	uploadOverlay.addEventListener('drop', handleDrop);

	// Reload button
	reloadBtn.addEventListener('click', () => {
		uploadOverlay.classList.remove('hidden');
		reloadBtn.classList.remove('visible');
		controls.classList.remove('visible');
	});
}

function loadImage(file) {
	const reader = new FileReader();
	reader.onload = (e) => {
		const loader = new THREE.TextureLoader();
		loader.load(e.target.result, (tex) => {
			texture = tex;

			// Create or update material
			const material = new THREE.MeshBasicMaterial({
				map: texture
			});

			if (sphere) {
				sphere.material.dispose();
				sphere.material = material;
			} else {
				const geometry = new THREE.SphereGeometry(500, 60, 40);
				geometry.scale(-1, 1, 1);
				sphere = new THREE.Mesh(geometry, material);
				scene.add(sphere);
			}

			uploadOverlay.classList.add('hidden');
			controls.classList.add('visible');
			reloadBtn.classList.add('visible');
			animate();
		});
	};
	reader.readAsDataURL(file);
}

function handleFileSelect(e) {
	const file = e.target.files[0];
	if (file && file.type.startsWith('image/')) {
		loadImage(file);
	}
}

function handleDragOver(e) {
	e.preventDefault();
	e.stopPropagation();
	uploadOverlay.classList.add('drag-over');
}

function handleDragLeave(e) {
	e.preventDefault();
	e.stopPropagation();
	uploadOverlay.classList.remove('drag-over');
}

function handleDrop(e) {
	e.preventDefault();
	e.stopPropagation();
	uploadOverlay.classList.remove('drag-over');

	const file = e.dataTransfer.files[0];
	if (file && file.type.startsWith('image/')) {
		loadImage(file);
	}
}

function onMouseDown(e) {
	isMouseDown = true;
	mouseX = e.clientX;
	mouseY = e.clientY;
}

function onMouseMove(e) {
	if (isMouseDown) {
		const deltaX = e.clientX - mouseX;
		const deltaY = e.clientY - mouseY;

		mouseX = e.clientX;
		mouseY = e.clientY;

		lon += deltaX * 0.1;
		lat -= deltaY * 0.1;
		lat = Math.max(-85, Math.min(85, lat));
	}
}

function onMouseUp() {
	isMouseDown = false;
}

let lastTouchX = 0,
	lastTouchY = 0;
let lastTouchDistance = 0;

function getTouchDistance(touches) {
	const dx = touches[0].clientX - touches[1].clientX;
	const dy = touches[0].clientY - touches[1].clientY;
	return Math.sqrt(dx * dx + dy * dy);
}

function onTouchStart(e) {
	if (e.touches.length === 1) {
		lastTouchX = e.touches[0].clientX;
		lastTouchY = e.touches[0].clientY;
	} else if (e.touches.length === 2) {
		lastTouchDistance = getTouchDistance(e.touches);
	}
}

function onTouchMove(e) {
	e.preventDefault();

	if (e.touches.length === 1) {
		// Single touch - pan/look around
		const deltaX = e.touches[0].clientX - lastTouchX;
		const deltaY = e.touches[0].clientY - lastTouchY;

		lastTouchX = e.touches[0].clientX;
		lastTouchY = e.touches[0].clientY;

		lon += deltaX * 0.1;
		lat -= deltaY * 0.1;
		lat = Math.max(-85, Math.min(85, lat));
	} else if (e.touches.length === 2) {
		// Two touches - pinch to zoom
		const touchDistance = getTouchDistance(e.touches);
		const delta = lastTouchDistance - touchDistance;

		camera.fov += delta * 0.1;
		camera.fov = Math.max(30, Math.min(120, camera.fov));
		camera.updateProjectionMatrix();

		lastTouchDistance = touchDistance;
	}
}

function onTouchEnd(e) {
	if (e.touches.length === 1) {
		// One finger still down, reset pan tracking
		lastTouchX = e.touches[0].clientX;
		lastTouchY = e.touches[0].clientY;
	}
}

function onWheel(e) {
	e.preventDefault();
	camera.fov += e.deltaY * 0.05;
	camera.fov = Math.max(30, Math.min(120, camera.fov));
	camera.updateProjectionMatrix();
}

function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
	requestAnimationFrame(animate);
	update();
	renderer.render(scene, camera);
}

function update() {
	lat = Math.max(-85, Math.min(85, lat));
	phi = THREE.MathUtils.degToRad(90 - lat);
	theta = THREE.MathUtils.degToRad(lon);

	const x = 500 * Math.sin(phi) * Math.cos(theta);
	const y = 500 * Math.cos(phi);
	const z = 500 * Math.sin(phi) * Math.sin(theta);

	camera.lookAt(x, y, z);
}

init();
	</script>
</body>
</html>